/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*
*/
#ifndef _SMALLVECTOR_HPP_
#define _SMALLVECTOR_HPP_

#include <memory>
#include <cstddef>


#include <boost/type_traits.hpp>

#include "ptr_iterator.hpp"

namespace hadoken {


namespace containers {

template<typename T, std::size_t N>
class small_vector{
public:
    typedef T                                               value_type;
    typedef T*                                              pointer;
    typedef const pointer                                   const_pointer;
    typedef value_type &                                    reference;
    typedef const value_type &                              const_reference;
    typedef iterator_ptr<value_type>                        iterator;
    typedef const iterator                                  const_iterator;
    typedef std::size_t                                     size_type;
    typedef std::ptrdiff_t                                  difference_type;

// not implemented now
//    typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
//    typedef std::reverse_iterator<iterator>		 reverse_iterator;
//    typedef _Alloc                        		 allocator_type;

    ///
    /// \brief default constructor, empty small_vector
    ///
    small_vector();

    ~small_vector();


    ///
    /// \brief return iterator to first value of small_vector
    ///
    iterator begin() noexcept{
        return iterator(_begin);
    }

    ///
    /// \brief return const_iterator to first value of small_vector
    ///
    const_iterator begin() const noexcept{
        return const_iterator(_begin);
    }
    ///
    /// \brief return iterator to first value of small_vector
    ///
    iterator end() noexcept{
        return iterator(_end);
    }

    ///
    /// \brief return const_iterator after the last element of small_vector
    ///
    const_iterator end() const noexcept{
        return const_iterator(_end);
    }


    ///
    /// \brief return const_iterator to first value of the small_vector
    ///
    size_type size() const noexcept{
        return static_cast<std::size_t>(_end - _begin);
    }

    ///
    /// \brief return const_iterator to first value of the small_vector
    ///
    void resize(size_type new_size);

    ///
    /// \brief maximum number of element that the small_vector can contain
    ///
    size_type max_size() const noexcept;


    ///
    /// \brief push_back
    /// \param v
    ///
    void push_back(const_reference elem);


    ///
    /// \brief emplace_back
    /// \param v
    ///
    void emplace_back(value_type && elem);

    ///
    /// \brief pop_back
    ///
    void pop_back();

    ///
    /// \brief front
    /// \return reference to the first element of the vector
    ///
    reference front();

    ///
    /// \brief front
    /// \return reference to the first element of the vector
    ///
    const_reference front() const noexcept;


    reference & back();

    ///
    /// \brief pointer to first element
    /// \return return a pointer to the first element
    pointer data() noexcept;


    ///
    /// \return true if small_vector contains no element
    ///
    bool empty() const noexcept;


    std::size_t capacity() const noexcept;

    ///
    /// \brief access operator
    /// \param position of the element to access
    /// \return reference to element pos
    ///
    reference at(std::size_t pos);

    ///
    /// \brief access operator
    /// \param position of the element to access
    /// \return reference to element pos
    ///
    const_reference at(std::size_t pos) const;

    ///
    /// \brief access operator
    /// \param position of the element to access
    /// \return reference to element pos
    ///
    reference operator[] (std::size_t pos) noexcept;

    ///
    /// \brief access operator
    /// \param position of the element to access
    /// \return const reference to element pos
    ///
    const_reference operator[] (std::size_t pos) const noexcept;

    ///
    /// \brief swap content of two small_vectors
    ///
    void swap(small_vector & other);

private:
    pointer _begin, _end, _end_memory;

    T _internal_array[N];


    void _resize_to_fit(std::size_t);

    bool _is_static() const noexcept;
};





} // containers



} //hadoken

#include "bits/small_vector_bits.hpp"

#endif // SMALLVECTOR_H
