/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*
*/
#ifndef SPMD_OPTS_HPP
#define SPMD_OPTS_HPP


#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <array>
#include <cassert>
#include <type_traits>


#ifndef HADOKEN_FORCE_INLINE
#define HADOKEN_FORCE_INLINE inline
#endif


#ifndef HADOKEN_FORCE_VECTORIZE
#define HADOKEN_FORCE_VECTORIZE
#endif 

#ifndef HADOKEN_SPMD_CONSTEXPR
#define HADOKEN_SPMD_CONSTEXPR constexpr
#endif 

namespace hadoken {

namespace spmd {

//
//
// Note: Why the choice of repeating for-loop instead of factorizing the code
//
// - Vectorization of for-loop is the most basic vectorization that all good C++ compilers provide
//
// - Some compiler are particularly sensitive to multi-layer templating and often
// loose inlining if templating is too deep
//
// - Some (stupid) compilers loose track of aligment over function calls, even template ones
//
//


template<typename NumType, std::size_t N, std::size_t Aligment>
class spmd_array;

template<typename Array, typename Scalar>
using ArrayOfScalar = typename std::enable_if<std::is_same<typename Array::value_type, Scalar>::value, Array>::type;

namespace {


    /*template<typename NonStaticArray>
    inline std::size_t spmd_get_size(const NonStaticArray &){
        static_assert(false, "Error ! not defined as static sized array");
        return 0;
    }*/


    template<typename StaticArray>
    constexpr
    std::size_t
//    typename std::enable_if<std::is_same<decltype(StaticArray::static_size), std::size_t>::value, std::size_t>::type
    spmd_get_size(const StaticArray &){
        return StaticArray::static_size; 
    }

}

//
// neg
//

// neg
template<typename Array>
HADOKEN_FORCE_INLINE Array neg(const Array & a){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = -a[i];
    }

    return res;
}




//
// plus
//

// plus
template<typename Array>
HADOKEN_FORCE_INLINE Array plus(const Array & a, const Array & b){
    assert(spmd_get_size(a) == spmd_get_size(b));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = a[i] + b[i];
    }

    return res;
}

// plus scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
plus(const Array & a, const Scalar & s){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = a[i] + s;
    }

    return res;
}

// plus scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
plus(const Scalar & scalar, const Array & array){
    return plus(array, scalar);
}



//
// minus
//

// minus
template<typename Array>
HADOKEN_FORCE_INLINE Array minus(const Array & array1, const Array & array2){
    assert(spmd_get_size(array1) == spmd_get_size(array2));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array1);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = array1[i] - array2[i];
    }

    return res;
}

// minus scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
minus(const Array & array, const Scalar & scalar){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = array[i] - scalar;
    }

    return res;
}

// minus scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
minus(const Scalar & scalar, const Array & array){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = scalar - array[i];
    }

    return res;
}


//
// mul
//

// mul
template<typename Array>
HADOKEN_FORCE_INLINE Array mul(const Array & a, const Array & b){
    assert(spmd_get_size(a) == spmd_get_size(b));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = a[i] * b[i];
    }

    return res;
}

// mul scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
mul(const Array & a, const Scalar & s){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = a[i] * s;
    }

    return res;
}

// mul scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
mul(const Scalar & scalar, const Array & array){
    return mul(array, scalar);
}



//
// div
//

// div
template<typename Array>
HADOKEN_FORCE_INLINE Array div(const Array & array1, const Array & array2){
    assert(spmd_get_size(array1) == spmd_get_size(array2));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array1);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = array1[i] / array2[i];
    }

    return res;
}

// div scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
div(const Array & array, const Scalar & scalar){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = array[i] / scalar;
    }

    return res;
}

// div scalar
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
ArrayOfScalar<Array,Scalar>
div(const Scalar & scalar, const Array & array){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(array);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = scalar / array[i];
    }

    return res;
}


//
// fma
//

// fma
template<typename Array>
HADOKEN_FORCE_INLINE Array fma(const Array & add1, const Array & mul1, const Array & mul2){
    assert(spmd_get_size(mul1) == spmd_get_size(add1) && spmd_get_size(mul1) == spmd_get_size(mul1));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(add1);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = add1[i] + mul1[i] * mul2[i];
    }

    return res;
}

// fma mul scalar
template<typename Array>
HADOKEN_FORCE_INLINE Array fma(const Array & add1, const Array & mul1, typename Array::value_type mul_scalar){
    assert(spmd_get_size(mul1) == spmd_get_size(add1));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(add1);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = add1[i] + mul1[i] * mul_scalar;
    }

    return res;
}

// fma mul scalar
template<typename Array>
HADOKEN_FORCE_INLINE Array fma(const Array & add1, typename Array::value_type  mul_scalar, 
const Array & mul1){
	return fma(add1, mul1, mul_scalar);
}



//
// min/max
//

// min
template<typename Array>
HADOKEN_FORCE_INLINE Array min(const Array & a, const Array & b){
    assert(spmd_get_size(a) == spmd_get_size(b));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    typedef typename Array::value_type NumType;

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::min<NumType>(a[i], b[i]);
    }

    return res;
}

// max
template<typename Array>
HADOKEN_FORCE_INLINE Array max(const Array & a, const Array & b){
    assert(spmd_get_size(a) == spmd_get_size(b));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    typedef typename Array::value_type NumType;

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::max<NumType>(a[i], b[i]);
    }

    return res;
}


//
// sqrt
//

// sqrt
template<typename Array>
HADOKEN_FORCE_INLINE Array sqrt(const Array & a){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::sqrt(a[i]);
    }

    return res;
}


//
// exp
//

// exp
template<typename Array>
HADOKEN_FORCE_INLINE Array exp(const Array & a){
    assert(spmd_get_size(a));
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::exp(a[i]);
    }

    return res;
}



//
// pow
//

// pow
template<typename Array1, typename Array2>
HADOKEN_FORCE_INLINE Array1 pow(const Array1 & a, const Array2 & b){
    assert(spmd_get_size(a) == spmd_get_size(b));
    Array1 res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::pow(a[i], b[i]);
    }

    return res;
}

// pow
template<typename Array, typename Scalar>
HADOKEN_FORCE_INLINE
typename std::enable_if<std::is_arithmetic<Scalar>::value, Array>::type
pow(const Array & a, const Scalar & scalar){
    Array res;
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(a);

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res[i] = std::pow(a[i], scalar);
    }

    return res;
}



//
// close to
//


//
// Check if each element of two same sized array are equal or close to equal in a given delta
//
template<typename Array>
typename std::enable_if<std::is_integral<typename Array::value_type>::value, bool>::type
close_to_abs(const Array & arr1, const Array & arr2, typename Array::value_type max_delta){
    assert(spmd_get_size(arr1) == spmd_get_size(arr2));

    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(arr1);

    typedef typename Array::value_type NumType;

    int res = 0;

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        const NumType biggest = std::max<NumType>(arr1[i], arr2[i]);
        const NumType smallest = std::min<NumType>(arr1[i], arr2[i]);

        res += ((biggest - smallest) <= max_delta);
    }

    return  (res == N);
}


template<typename Array>
typename std::enable_if<std::is_floating_point<typename Array::value_type>::value, bool>::type
close_to_abs(const Array & arr1, const Array & arr2, typename Array::value_type max_delta){
    assert(spmd_get_size(arr1) == spmd_get_size(arr2));
    HADOKEN_SPMD_CONSTEXPR std::size_t N = spmd_get_size(arr1);

    int res = 0;

    HADOKEN_FORCE_VECTORIZE
    for(std::size_t i = 0; i < N; i++){
        res += (std::fabs(arr1[i] - arr2[i]) <= max_delta);
    }

    return  (res == N);
}


} // spmd


} // hadoken

#endif // SPMD_OPTS_HPP

