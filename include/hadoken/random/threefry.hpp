/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*
*/


//
// This work is derivated from the boost.Random123
// repository accessible here https://github.com/DEShawResearch/Random123-Boost
//
//

#ifndef _HADOKEN_RANDOM_THREEFRY_
#define _HADOKEN_RANDOM_THREEFRY_

#include <boost/array.hpp>
#include <boost/integer.hpp>
#include <boost/static_assert.hpp>
#include <boost/cstdint.hpp>
#include <boost/random/seed_seq.hpp>

#include <boost/limits.hpp>
#include <boost/mpl/range_c.hpp>
#include <boost/mpl/for_each.hpp>




///
///  threefry is a state-less counter base random generator
///  derivated from the block cipher threefish
///  part of the "The Skein Hash Function Family" by
///   Niels Ferguson, Stefan Lucks, Bruce Schneier, Doug Whiting
///   Mihir Bellare, Tadayoshi Kohno, Jon Callas, Jesse Walker (
///
///   threefry has been presented at SC11 in the publication
///
/// "Parallel random numbers: as easy as 1, 2, 3".
///    John K. Salmon, Mark A. Moraes, Ron O. Dror, David E. Shaw" (doi:10.1145/2063384.2063405)
///
///  This implementation is freely inspired of Boost.Random123  (https://github.com/DEShawResearch/Random123-Boost )
///



namespace hadoken{

// threefry_constants is an abstract template that will be
// specialized with the KS_PARITY and Rotation constants
// of the threefry generators.  These constants are carefully
// chosen to achieve good randomization.  
//  threefry_constants<2, uint32_t>
//  threefry_constants<2, uint64_t>
//  threefry_constants<4, uint32_t>
//  threefry_constants<4, uint64_t>
// The constants here are from Salmon et al <FIXME REF>.
//
// See Salmon et al, or Schneier's original work on Threefish <FIXME
// REF> for information about how the constants were obtained.
template <unsigned _N, typename Uint>
struct threefry_constants{
};

// 2x32 constants
template <>
struct threefry_constants<2, uint32_t>{
    static const uint32_t KS_PARITY = UINT32_C(0x1BD11BDA);
    static const unsigned Rotations[8];
};
const unsigned
threefry_constants<2, uint32_t>::Rotations[]  =
    {13, 15, 26, 6, 17, 29, 16, 24};

// 4x32 contants
template <>
struct threefry_constants<4, uint32_t>{
    static const uint32_t KS_PARITY = UINT32_C(0x1BD11BDA);
    static const unsigned Rotations0[8];
    static const unsigned Rotations1[8];
};
const unsigned
threefry_constants<4, uint32_t>::Rotations0[]  = 
    {10, 11, 13, 23, 6, 17, 25, 18};

const unsigned
threefry_constants<4, uint32_t>::Rotations1[]  = 
    {26, 21, 27, 5, 20, 11, 10, 20};

// 2x64 constants
template <>
struct threefry_constants<2, uint64_t>{
    static const uint64_t KS_PARITY = UINT64_C(0x1BD11BDAA9FC1A22);
    static const unsigned Rotations[8];
};
const unsigned
threefry_constants<2, uint64_t>::Rotations[]  =
    {16, 42, 12, 31, 16, 32, 24, 21};

// 4x64 constants
template <>
struct threefry_constants<4, uint64_t>{
    static const uint64_t KS_PARITY = UINT64_C(0x1BD11BDAA9FC1A22);
    static const unsigned Rotations0[8];
    static const unsigned Rotations1[8];
};
const unsigned
threefry_constants<4, uint64_t>::Rotations0[]  = 
    {14, 52, 23, 5, 25, 46, 58, 32};

const unsigned
threefry_constants<4, uint64_t>::Rotations1[]  = {
    16, 57, 40, 37, 33, 12, 22, 32};



template <typename Uint>
inline Uint threefry_rotl(Uint x, unsigned s){
    return (x<<s) | (x>>(std::numeric_limits<Uint>::digits-s));
}



template <unsigned N, typename Uint, unsigned R=20, typename Constants=threefry_constants<N, Uint> >
class threefry{
    BOOST_STATIC_ASSERT( N==2 || N==4 );
    // should never be instantiated.
    // Only the specializations on N=2 and 4 are
    // permitted/implemented.
};

// specialize threefry<2, Uint, R>
template<typename Uint, unsigned R, typename Constants>
class threefry<2, Uint, R, Constants>{
public:
    typedef boost::array<Uint, 2> domain_type;
    typedef boost::array<Uint, 2> range_type;
    typedef boost::array<Uint, 2> key_type;
    typedef Uint                  uint_type;

    threefry() : k(){}
    threefry(key_type _k) : k(_k) {}
    threefry(const threefry& v) : k(v.k){}

    void setkey(key_type _k){
        k = _k;
    }

    key_type getkey() const{
        return k;
    }


    bool operator==(const threefry& rhs) const{
        return (k == rhs.k);
    }

    bool operator!=(const threefry& rhs) const{
        return (k != rhs.k);
    }

    range_type operator()(domain_type c){
        uint_type ks[3];
        ks[2] = Constants::KS_PARITY;
        ks[0] = k[0]; ks[2] ^= k[0]; c[0] += k[0];
        ks[1] = k[1]; ks[2] ^= k[1]; c[1] += k[1];

        for(unsigned r=0; r<R; ){
            c[0] += c[1]; c[1] = threefry_rotl(c[1],Constants::Rotations[r%8]); c[1] ^= c[0];
            ++r;
            if((r&3)==0){
                unsigned r4 = r>>2;
                c[0] += ks[r4%3]; 
                c[1] += ks[(r4+1)%3] + r4;
            }
        }
        return c;

    }

private:
    key_type k;
};

// specialize threefry<4, Uint, R>
template<typename Uint, unsigned R, typename Constants>
class threefry<4, Uint, R, Constants>{
public:
    typedef boost::array<Uint, 4> domain_type;
    typedef boost::array<Uint, 4> range_type;
    typedef boost::array<Uint, 4> key_type;
    typedef Uint                  uint_type;

    threefry() : k(){}
    threefry(key_type _k) : k(_k) {}
    threefry(const threefry& v) : k(v.k){}

    void setkey(key_type _k){
        k = _k;
    }

    key_type getkey() const{
        return k;
    }




    bool operator==(const threefry& rhs) const{
        return k == rhs.k;
    }

    bool operator!=(const threefry& rhs) const{
        return k != rhs.k;
    }

    range_type operator()(domain_type c){ 
        uint_type ks[5];
        ks[4] = Constants::KS_PARITY;
        ks[0] = k[0]; ks[4] ^= k[0]; c[0] += k[0];
        ks[1] = k[1]; ks[4] ^= k[1]; c[1] += k[1];
        ks[2] = k[2]; ks[4] ^= k[2]; c[2] += k[2];
        ks[3] = k[3]; ks[4] ^= k[3]; c[3] += k[3];


        for(unsigned r=0; r<R; ){
            if((r&1)==0){
                c[0] += c[1]; c[1] = threefry_rotl(c[1],Constants::Rotations0[r%8]); c[1] ^= c[0];
                c[2] += c[3]; c[3] = threefry_rotl(c[3],Constants::Rotations1[r%8]); c[3] ^= c[2];
            }else{
                c[0] += c[3]; c[3] = threefry_rotl(c[3],Constants::Rotations0[r%8]); c[3] ^= c[0];
                c[2] += c[1]; c[1] = threefry_rotl(c[1],Constants::Rotations1[r%8]); c[1] ^= c[2];
            }
            ++r;
            if((r&3)==0){
                unsigned r4 = r>>2;
                c[0] += ks[(r4+0)%5]; 
                c[1] += ks[(r4+1)%5];
                c[2] += ks[(r4+2)%5];
                c[3] += ks[(r4+3)%5] + r4;
            }
        }
        return c; 
    }

private:

    key_type k;
};



typedef threefry<2, boost::uint32_t> threefry2x32;
typedef threefry<4, boost::uint32_t> threefry4x32;


typedef threefry<2, boost::uint64_t> threefry2x64;
typedef threefry<4, boost::uint64_t> threefry4x64;



}

#endif // _HADOKEN_RANDOM_THREEFRY_
