/**
 * Copyright (c) 2018, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*
*/
#pragma once


#include "../getopts.hpp"

#include "../../format/format.hpp"

namespace hadoken{



inline void options_handler::add_option(option opt){
    _opts.emplace_back(opt);
}

inline void options_handler::add_subcommand(sub_command sub_com){
    _subcmd.emplace_back(sub_com);
}


const std::vector<sub_command> & options_handler::sub_commands() const{
    return _subcmd;
}

const std::vector<option> & options_handler::options() const{
    return _opts;
}


inline sub_command::sub_command(string_view subcommand_name, std::function<void (void)> &callback, string_view help_msg) :
    _name(subcommand_name),
    _help_msg(help_msg),
    _options(),
    _action(callback){

}

inline void sub_command::add_option(option opt){
    _options.emplace_back(opt);
}

inline string_view sub_command::name() const{
    return _name;
}

inline void sub_command::_call() const{
    _action();
}

inline option::option(string_view option_name, string_view help_msg, std::function<void (std::string)> callback) :
    _name(option_name),
    _help_msg(help_msg),
    _action()
{
    _action = [callback](string_view arg) -> void{
            callback(to_string(arg));
    };
}


inline option::option(string_view option_name, string_view help_msg, std::function<void (int)> callback) :
    _name(option_name),
    _help_msg(help_msg),
    _action()
{
    _action = [callback, this](string_view arg) -> void{
        try{
            callback(std::stoi(to_string(arg)));
        }catch(std::exception & e){
            throw std::runtime_error(scat("invalid argument for ", _name, " not a valid <int>"));
        }
    };
}


inline  string_view option::name() const{
    return _name;
}


inline void parse_options(const options_handler & opt_handler, int argc, char** argv){
    std::vector<string_view> options;
    for(int i = 1; i < argc; ++i){
        options.emplace_back(argv[i]);
    }
    parse_options(opt_handler, string_view(argv[0]), options);
}


inline void print_help(const string_view &, sub_command &){

}


bool _compare_option(string_view candidate_opt, string_view value){
    if(candidate_opt.size() == 0){
        throw std::invalid_argument("empty option is not suppored");
    }
    return true;
}

template<typename Iterator>
inline void _validate_and_call(std::vector<options_handler const *> stack, string_view prog_name, Iterator begin_arg, Iterator end_arg, bool call){
    if (begin_arg >= end_arg){
        return;
    }

    const options_handler & opt_handler = *stack.back();

    // check for subcommands
    for(const sub_command & sub : opt_handler.sub_commands()){
        if(begin_arg->compare(sub.name()) == 0){
            stack.emplace_back(&sub);
            if(call){
                sub._call();
            }
            return _validate_and_call(stack, prog_name, begin_arg +1, end_arg, call);
        }
    }

    /* check for options
    for(const option & opt : opt_handler.options()){
        if(begin_arg->compare(opt.name()) == 0){
            if(call){
                sub._call();
            }
            return _validate_and_call(stack, prog_name, begin_arg +1, end_arg, call);
        }
    }*/
}


inline void parse_options(const options_handler & opt_handler, string_view prog_name, const std::vector<string_view> & options){

    std::vector<options_handler const *> stack;
    stack.push_back(&opt_handler);

    // dry run, check options
    _validate_and_call(stack, prog_name, options.begin(), options.end(), false);

    // call callbacks
    _validate_and_call(stack, prog_name, options.begin(), options.end(), true);
}

} // hadoken
