/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 * 
 * Boost Software License - Version 1.0 
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
* 
*/

#define BOOST_TEST_MODULE formatTests
#define BOOST_TEST_MAIN

#include <iostream>
#include <sstream>

#include <boost/test/unit_test.hpp>

#include <hadoken/format/format.hpp>
#include <hadoken/format/format_template.hpp>

BOOST_AUTO_TEST_CASE( simple_format_concat_test )
{
    using namespace hadoken::format;

    std::ostringstream ss1, ss2;

    scat(ss1, "hello world ", "Bob", "!");

    ss2 << "hello world " << "Bob" << "!";

    BOOST_CHECK_EQUAL(ss1.str(), ss2.str());
}




BOOST_AUTO_TEST_CASE( simple_format_concat_int_float_test )
{
    using namespace hadoken::format;

    std::ostringstream ss1, ss2;

    const int val = 42;
    const float valf = 42.0;

    scat(ss1, "hello world ", val , " ", valf, "!");

    ss2 << "hello world " << val << " " << valf << "!";

    BOOST_CHECK_EQUAL(ss1.str(), ss2.str());
}



BOOST_AUTO_TEST_CASE( concat_to_string_test )
{
    using namespace hadoken::format;

    const std::string valid_string = "hello world 42 stupid test";

    std::string res = scat("hello world ", 42, " stupid test");



    BOOST_CHECK_EQUAL(res, valid_string);

    std::cout << res << std::endl;
}






BOOST_AUTO_TEST_CASE( format_template_test )
{
    using namespace hadoken::format;

    const std::string string_template = "hello {my_var1}, from the {my_var2}";
    std::string res;

    // full replace
    res = format_template(string_template, { std::make_tuple("my_var1", "world"), std::make_tuple("my_var2", "multiverse")});

    BOOST_CHECK_EQUAL(res, "hello world, from the multiverse");

    std::cout << res << std::endl;

    // partial replace
    res = format_template(string_template, { std::make_tuple("my_var1", "world")});
    BOOST_CHECK_EQUAL(res, "hello world, from the {my_var2}");

}

