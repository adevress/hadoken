/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 * 
 * Boost Software License - Version 1.0 
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
* 
*/
#define BOOST_TEST_MODULE randomTests
#define BOOST_TEST_MAIN

#include <boost/test/included/unit_test.hpp>
#include <boost/test/floating_point_comparison.hpp>


#include <boost/random.hpp>

#include <hadoken/random/random.hpp>


BOOST_AUTO_TEST_CASE( simple_random_tests )
{
    const std::size_t n_vals = 1000;

    boost::random::mt11213b twister_engine;

    boost::random::uniform_int_distribution<int> dist(0, n_vals);

    std::vector<int> origin_values;
    origin_values.reserve(n_vals);

    // simple silly test to fullfill original twister
    // random generator vector
    for(std::size_t i =0; i < n_vals; ++i){
        const int v = dist(twister_engine);
        origin_values.push_back(v);
        BOOST_CHECK_GE(v, 0);
        BOOST_CHECK_LE(v, n_vals);
    }

    boost::random::mt11213b twister_engine_clone;
    hadoken::random_engine_mapper engine_mapper(twister_engine_clone);

    std::vector<int> mapper_values;
    mapper_values.reserve(n_vals);

    // simple silly test to fullfill original twister
    // random generator vector
    for(std::size_t i =0; i < n_vals; ++i){
        const int v = dist(engine_mapper);
        mapper_values.push_back(v);
        BOOST_CHECK_GE(v, 0);
        BOOST_CHECK_LE(v, n_vals);
    }

    BOOST_CHECK_EQUAL_COLLECTIONS(origin_values.begin(), origin_values.end(),
                                  mapper_values.begin(), mapper_values.end());

}



BOOST_AUTO_TEST_CASE( simple_derivate)
{
    const std::size_t n_vals = 1000;

    boost::random::uniform_int_distribution<std::size_t> dist;

    std::vector<std::size_t> origin_values, derivated_values;
    origin_values.reserve(n_vals);



    const int seed = 424242;
    boost::random::mt11213b twister_engine_clone;
    hadoken::random_engine_mapper engine_mapper(twister_engine_clone);
    engine_mapper.seed(seed);


    // create a derivation with a terrible seed init difference  1
    hadoken::random_engine_mapper derivated_engine = engine_mapper.derivate(1);


    // simple silly test to fullfill original twister
    // random generator vector
    for(std::size_t i =0; i < n_vals; ++i){
        unsigned int v1 = dist(engine_mapper);
        origin_values.push_back(v1);

        unsigned int v2= dist(derivated_engine);
        derivated_values.push_back(v2);

        std::cout << "random_num_twins: " << v1 << " " << v2 << std::endl;

        BOOST_CHECK_NE(v1, v2);
    }

}


BOOST_AUTO_TEST_CASE( determinism_derivate)
{
    const std::size_t n_vals = 1000;

    boost::random::uniform_int_distribution<std::size_t> dist;

    std::vector<std::size_t> origin_values, derivated_values, derivated_values_same, derivated_values_differ;
    origin_values.reserve(n_vals);


    const int seed = 1234;
    boost::random::mt11213b twister_engine_clone;
    hadoken::random_engine_mapper engine_mapper(twister_engine_clone);
    engine_mapper.seed(seed);



    // create two derivation with the same key, they should behave in the same way
    hadoken::random_engine_mapper derivated_engine = engine_mapper.derivate(42);
    hadoken::random_engine_mapper derivated_engine_same = engine_mapper.derivate(42);
    
    // create a second one as double derivative as reference
    hadoken::random_engine_mapper derivated_engine_differ = derivated_engine_same.derivate(43);

   

    // simple silly test to fullfill original twister
    // random generator vector
    for(std::size_t i =0; i < n_vals; ++i){
        unsigned int v1 = dist(engine_mapper);
        origin_values.push_back(v1);

        unsigned int v2= dist(derivated_engine);
        derivated_values.push_back(v2);

	unsigned int v3 = dist(derivated_engine_same);
	derivated_values_same.push_back(v3);

	unsigned int v4 = dist(derivated_engine_differ);
	derivated_values_differ.push_back(v4);

	
        BOOST_CHECK_NE(v1, v2);
	BOOST_CHECK_NE(v1, v3);
	BOOST_CHECK_NE(v1, v4);

	BOOST_CHECK_EQUAL(v2, v3);

	BOOST_CHECK_NE(v2, v4);
	BOOST_CHECK_NE(v2, v4);

	std::cout << "randum_num_diff: " << v1 << " " << v2 << " " << v3 << " " << v4 << "\n";
    }

}

