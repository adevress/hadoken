/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#define BOOST_TEST_MODULE genericTests
#define BOOST_TEST_MAIN

#include <iostream>
#include <map>
#include <cmath>

#include <boost/array.hpp>
#include <boost/math/constants/constants.hpp>
#include <boost/test/floating_point_comparison.hpp>
#include <boost/test/unit_test.hpp>
#include <boost/variant.hpp>

#include <hadoken/numeric/convert.hpp>
#include <hadoken/numeric/float.hpp>
#include <hadoken/numeric/histogram.hpp>

#include <hadoken/string/wildcard.hpp>

#include <hadoken/utility/optional.hpp>
#include <hadoken/utility/variant.hpp>




BOOST_AUTO_TEST_CASE(optional_to_variant) {

    hadoken::variant<int, float, std::string> my_variant;

    hadoken::optional<std::string> my_opt;

    BOOST_CHECK(!my_opt);
    BOOST_CHECK_EQUAL(bool(my_opt), false);

    BOOST_CHECK_EQUAL(my_variant.which(), 0);

    my_variant = hadoken::to_variant<hadoken::variant<int, float, std::string>>(my_opt);
    BOOST_CHECK_EQUAL(my_variant.which(), 0);
}




BOOST_AUTO_TEST_CASE(integral_convertion) {
    using namespace hadoken;

    // dummy integer convert
    int a = to_integral<int>("5");
    BOOST_CHECK_EQUAL(a, 5);

    // different base
    a = to_integral<int>("0x10", 16);
    BOOST_CHECK_EQUAL(a, 16);

    // force on size_t
    std::size_t value = to_integral<std::size_t>("5000");
    BOOST_CHECK_EQUAL(value, 5000);


    // check exception
    BOOST_CHECK_THROW(
        {
            long long value = to_integral<long long>("to the infinite and beyond");
            (void)value;
        },
        std::invalid_argument);


    // check unsigned int
    unsigned int u_value = to_integral<unsigned int>(std::to_string(std::numeric_limits<unsigned int>::max()));
    BOOST_CHECK_EQUAL(u_value, std::numeric_limits<unsigned int>::max());

    // check fixed size convertion
    std::uint64_t u64_value = to_integral<std::uint64_t>("42");
    BOOST_CHECK_EQUAL(u64_value, 42);


    // check floating point
    double d = to_floating<double>("42.88");
    BOOST_CHECK(close_to_abs(42.88, d));
}




BOOST_AUTO_TEST_CASE(basic_histogram_test) {
    using namespace hadoken;

    const double pi = 4* std::atan(1);
    logarithmic_histogram<double> histo(-200, 200, pi);

    BOOST_CHECK_EQUAL(histo.size(), 6);

    BOOST_CHECK_EQUAL(histo.cardinality(), 0);


    for(std::size_t i = 0; i < histo.size(); ++i){
        BOOST_CHECK_EQUAL(std::get<2>(histo.get_bin(i)), 0);
    }


    // add extreme negative value out of scope
    histo.add_value(-8000);
    BOOST_CHECK_EQUAL(histo.cardinality(), 1);

    auto b0 = histo.get_bin(0);
    BOOST_CHECK_EQUAL(std::get<0>(b0), std::numeric_limits<double>::lowest());
    BOOST_CHECK_EQUAL(std::get<1>(b0), -200 + pi);
    BOOST_CHECK_EQUAL(std::get<2>(b0), 1);



    // add extreme positive value out of scope
    histo.add_value(8000);
    BOOST_CHECK_EQUAL(histo.cardinality(), 2);

    auto b_end = histo.get_bin(histo.size() -1);
    BOOST_CHECK_EQUAL(std::get<0>(b_end), -200.0 + std::pow(pi, histo.size() -1));
    BOOST_CHECK_EQUAL(std::get<1>(b_end), std::numeric_limits<double>::max());
    BOOST_CHECK_EQUAL(std::get<2>(b_end), 1);


    // add X bins randomly in middle
    const std::size_t nb_insert = 100;
    for(std::size_t i = 0; i < nb_insert ; ++i){
        histo.add_value(0.1);
    }

    BOOST_CHECK_EQUAL(histo.cardinality(), 102);

    auto b_middle = histo.get_bin(4);
    BOOST_CHECK_EQUAL(std::get<2>(b_middle), 100);

    BOOST_CHECK_GE(histo.sum(), 9.9);
    BOOST_CHECK_LE(histo.sum(), 10.1);

}
