/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#ifndef TEST_HELPERS_HPP
#define TEST_HELPERS_HPP

#include <algorithm>
#include <cmath>
#include <memory>
#include <random>
#include <string>
#include <type_traits>


template <typename T, typename Extra = void>
struct content_generator {

    static_assert(sizeof(T) != -1, "Need to be specialized");
};

template <>
struct content_generator<std::string, void> {

    std::string operator()(std::size_t n) {
        const std::size_t s = std::max<std::size_t>(std::log(n + 1), 1);

        std::ostringstream ss;
        for (std::size_t i = 0; i < s; ++i) {
            ss << "hello world ";
        }
        return ss.str();
    }
};


template <>
struct content_generator<std::unique_ptr<std::string>> {

    std::unique_ptr<std::string> operator()(std::size_t n) {
        content_generator<std::string, void> gen;

        return std::unique_ptr<std::string>(new std::string(gen(n)));
    }
};




template <typename T>
struct content_generator<T, typename std::enable_if<std::is_arithmetic<T>::value>::type> {

    T operator()(std::size_t n) { return T(n) + T(n * 0.1); }
};


std::string random_string_generator(std::size_t string_size, int seed) {
    std::string random_string;
    std::mt19937 gen(seed);

    random_string.reserve(string_size);

    for (std::size_t i = 0; i < string_size; ++i) {
        random_string.push_back(char(gen()));
    }
    return random_string;
}


#endif // TEST_HELPERS_HPP
